#include "se3_fatfs.h"
#include "se3_rand.h"

#pragma pack(push,1) //These are a physical structures, thus we don't want to allow
					// the compiler to insert padding for memory alignment
//Private structures
typedef struct
{
	//Plaintext
	uint8_t nonce_pbkdf2[SE3_FATFS_NONCE_LEN];	/**< 32 random bytes storing the IV for generating a different key*/
	uint32_t key_id;		/**< The ID of the key used to encrypt this file. */
	uint16_t algorithm;		/**< The algorithm used to encrypt this file. */
	uint8_t padding[10];	/**< Padding used to reach a SEkey header size which is a multiple of 16. */

	//Encoded
	uint8_t nonce_ctr[SE3_FATFS_IV_LEN];       /**< 16 random bytes storing the IV for next sectors*/
    int32_t magic;				            /**< 4 bytes used to represent file type (not used yet)*/
    int16_t ver;				            /**< 2 bytes used to represent current filesystem version (not used yet)*/
    int32_t uid;				            /**< 4 bytes not used yet*/
    int32_t uid_cnt;			            /**< 4 bytes not used yet*/
    uint8_t fname_len;			            /**< 1 byte to express how long is the filename.*/
} SE3_FATFS_HEADER;

typedef struct
{
	// Union allows us to access the structure also as an array
	union
	{
		struct
		{
			// notice that the size of the SE3_FATFS_SECTOR does depend on the union.
			//The size of the union is the size of the largest data inside the union (plus memory alignment if any).
			union
			{
				SE3_FATFS_HEADER header;               /**< See \ref SE3_FATFS_HEADER .*/
				uint8_t logic_data[SE3_FATFS_LOGIC_DATA];   /**< In here it will be written the actual data.
													 *   Since it is inside a union data type, the
													 *   filename will be written from 32nd byte.
													 */
			};
			uint16_t len;                      /**< How many bytes are actually stored in this sector.*/
			uint8_t signature[SE3_FATFS_SIGNATURE_LEN];             /**< Authenticated digest generated by the device*/
		};
		uint8_t data[SE3_FATFS_SECTOR_SIZE];
	};
} SE3_FATFS_SECTOR;

#pragma pack(pop)

//static bool find_and_read_key(uint32_t keyID, se3_fatfs_key* key);
static SE3_FRESULT crypto_filename(char *path, char *enc_name_path, uint16_t *encoded_length);
static SE3_FRESULT crypt_header(uint8_t* input_data, uint8_t* output_data, uint16_t algo, uint32_t keyID, uint16_t direction);
static SE3_FRESULT initialise_crypto_context(uint16_t algo, uint32_t keyID, uint16_t mode, uint32_t* sid);
static SE3_FRESULT set_nonce(uint32_t sid, uint8_t* nonce, uint16_t nonce_len);
static SE3_FRESULT execute_crypto_header(uint32_t sid, uint8_t* input_data, uint8_t* output_data);
static SE3_FRESULT getSHA256string(uint8_t* input, int length, uint8_t* output);
static void get_filename(char *path, char *file_name, size_t maxLength);
static void get_path(char *full_path, char *path);
static SE3_FRESULT secure_create(SE3_FIL* se_fp, char* path, BYTE mode);
static SE3_FRESULT load_existing_file(SE3_FIL* se_fp, char* path, BYTE mode);
static SE3_FRESULT read_sector(SE3_FIL* se_fp, uint32_t sector_id, uint8_t* data, uint16_t* data_len);
static SE3_FRESULT write_sector(SE3_FIL* se_fp, uint32_t sector_id);
static SE3_FRESULT crypt_sector(uint8_t* input_data, uint8_t* output_data, uint16_t algo, uint32_t keyID, uint8_t* IV, uint16_t direction);
static SE3_FRESULT execute_crypto_sector(uint32_t sid, uint8_t* input_data, uint8_t* output_data);
static SE3_FRESULT set_IV(uint32_t sid, uint8_t* IV, uint16_t IV_len);
static void compute_IV(uint8_t* base_IV, uint8_t* sector_IV, uint32_t sector_id);
static SE3_FRESULT get_filesize(SE3_FIL* se_fp, uint32_t* filesize);
static bool key_exists(uint32_t keyID);
static bool validate_file_object(SE3_FIL* se_fp);
static SE3_FRESULT set_file_pointer(SE3_FIL* se_fp, uint32_t new_pointer);
static SE3_FRESULT to_SE3_FRESULT(FRESULT res);

SE3_FRESULT secure_open(SE3_FIL* se_fp, char *path, BYTE mode, uint32_t keyID, uint16_t algo)
{
	SE3_FRESULT res;

	if (se_fp == NULL)
		return SE3_FR_INVALID_OBJECT;

	if (mode & FA_OPEN_ALWAYS)
		return SE3_FR_NOT_IMPLEMENTED;

	se_fp->mode = mode;

	//Create a new file if needed
	if (mode & (FA_CREATE_ALWAYS | FA_CREATE_NEW))
	{
		se_fp->algo = algo;
		se_fp->keyID = keyID;
		if ((res = secure_create(se_fp, path, mode | FA_READ)))
			return res;
	}
	else
	{
	//Otherwise open existing
		if ((res = load_existing_file(se_fp, path, mode | FA_READ) ))
			return res;
	}

	//Initialize remaining fields
	se_fp->pointer = 0;
	se_fp->dirty_bit = false;


	//Read first sector or create a new one if file is empty
	res = read_sector(se_fp, 1, se_fp->decrypt_buffer, &se_fp->decrypt_buffer_size);

	if (res == SE3_FR_EOF)
		se_fp -> decrypt_buffer_size = 0;
	else if (res != SE3_FR_OK)
		return res;

	return SE3_FR_OK;
}

SE3_FRESULT secure_seek(SE3_FIL* se_fp, int64_t offset, uint32_t *position, uint8_t whence)
{
	SE3_FRESULT res;
	uint32_t start;
	int64_t req_position;
	uint32_t filesize;


	//old variables used for file expanding functionality
	//uint32_t padding_len;
	//uint8_t *padding;

	if (!validate_file_object(se_fp))
			return SE3_FR_INVALID_OBJECT;

	if ((res = get_filesize(se_fp, &filesize)))
		return res;

	if(whence == SE3_FATFS_CURRENT)
		start = se_fp->pointer;
	else if(whence == SE3_FATFS_END)
		start = filesize;
	else
		start = 0;

	req_position = (int64_t) start + offset;

	if(req_position < 0)
		return SE3_FR_SEEK_ERROR;

	if (req_position > filesize)
		req_position = filesize;

	if ((res = set_file_pointer(se_fp, (uint32_t) req_position)))
		return res;

	//old code used to extend the file in case of a seek moving the pointer past the file ending
	/*if(req_position <= filesize)
	{

	}
	else
	{
		padding_len = (start + offset) - filesize;

		if ((padding = malloc(padding_len * sizeof(int))) == NULL)
			return SE3_FR_SEEK_ALLOCATION_ERROR;
		memset(padding, 0, padding_len);

		if((res = secure_write(se_fp, padding, padding_len)))
			return res;

		if((res = write_sector(se_fp, se_fp->pointer / SE3_FATFS_LOGIC_DATA + 1)))
			return res;
		return SE3_FR_SEEK_ERROR;
	}*/

	if (position != NULL)
		*position = se_fp->pointer;

	return SE3_FR_OK;

}

SE3_FRESULT secure_read(SE3_FIL* se_fp, uint8_t *dataOut, uint32_t dataOut_len, uint32_t *bytesRead)
{
	SE3_FRESULT res;
	uint32_t remaining_data;
	uint32_t read_pointer;
	uint16_t bytes_to_read;
	uint16_t sector_offset;
	bool eof;

	if (!validate_file_object(se_fp))
		return SE3_FR_INVALID_OBJECT;

	if (! (se_fp->mode & FA_READ))
		return SE3_FR_DENIED;

	read_pointer = 0;
	remaining_data = dataOut_len;
	eof = false;
	//Read until output buffer is filled up or end of file is reached
	while (remaining_data > 0 && !eof)
	{

		sector_offset = (uint16_t) (se_fp->pointer % SE3_FATFS_LOGIC_DATA);

		//Check if enough data is available in the decrypt buffer
		if (remaining_data + sector_offset >= SE3_FATFS_LOGIC_DATA)
			bytes_to_read = SE3_FATFS_LOGIC_DATA - sector_offset; 	/*Read all data in the buffer*/
		else
			bytes_to_read = remaining_data;

		//Check if end of file has been reached
		if (bytes_to_read > se_fp->decrypt_buffer_size - sector_offset)
		{
			eof = true;
			bytes_to_read = se_fp->decrypt_buffer_size - sector_offset;
		}

		//Copy data to output buffer
		memcpy(dataOut + read_pointer, se_fp->decrypt_buffer + sector_offset,  bytes_to_read);

		//update pointers
		if ((res = set_file_pointer(se_fp, se_fp->pointer + bytes_to_read)))
			return res;
		read_pointer += bytes_to_read;
		remaining_data -= bytes_to_read;

	}

	if (bytesRead != NULL)
		*bytesRead = read_pointer;

	return SE3_FR_OK;
}

SE3_FRESULT secure_write(SE3_FIL* se_fp, uint8_t *dataIn, uint32_t dataIn_len)
{
	SE3_FRESULT res;
	uint32_t remaining_data;
	uint32_t write_pointer;
	uint16_t bytes_to_write;
	uint16_t sector_offset;

	if (!validate_file_object(se_fp))
			return SE3_FR_INVALID_OBJECT;

	if (! (se_fp->mode & FA_WRITE))
		return SE3_FR_DENIED;

	write_pointer = 0;
	remaining_data = dataIn_len;

	//Write until all input buffer data have been written
	while (remaining_data > 0)
	{
		sector_offset = (uint16_t) (se_fp->pointer % SE3_FATFS_LOGIC_DATA);

		//Check if enough space is available in the decrypt buffer
		if (remaining_data + sector_offset >= SE3_FATFS_LOGIC_DATA)
			bytes_to_write = SE3_FATFS_LOGIC_DATA - sector_offset; /*Fill all the available space in the buffer*/
		else
			bytes_to_write = remaining_data;

		//Copy data to decrypt buffer
		memcpy(se_fp->decrypt_buffer + sector_offset, dataIn + write_pointer, bytes_to_write);

		//Update sector size
		if (sector_offset+bytes_to_write > se_fp->decrypt_buffer_size)
			se_fp->decrypt_buffer_size = sector_offset+bytes_to_write;

		se_fp->dirty_bit = true; /*mark decrypt_sector as dirty*/

		//Update pointers
		if ((res = set_file_pointer(se_fp, se_fp->pointer+bytes_to_write) ))
			return res;
		write_pointer += bytes_to_write;
		remaining_data -= bytes_to_write;
	}

	return SE3_FR_OK;
}

SE3_FRESULT secure_close(SE3_FIL* se_fp)
{
	SE3_FRESULT res;
	uint32_t curr_sector;
	if (!validate_file_object(se_fp))
			return SE3_FR_INVALID_OBJECT;

	curr_sector = se_fp->pointer / SE3_FATFS_LOGIC_DATA + 1;

	//Save current sector if needed
	if (se_fp->decrypt_buffer_size > 0 && se_fp->dirty_bit)
	{
		if (( res = write_sector(se_fp, curr_sector) ))
			return res;
	}

	//Close raw file
	if ( (res = to_SE3_FRESULT(f_close(&(se_fp->fp))) ) )
			return res;

	return SE3_FR_OK;
}

static
SE3_FRESULT load_existing_file(SE3_FIL* se_fp, char* path, BYTE mode)
{
	SE3_FRESULT res;
	SE3_FATFS_SECTOR header_sector;
	SE3_FATFS_SECTOR encoded_header_sector;
	UINT br;
	char enc_name_path[MAX_PATHNAME];
	uint16_t encoded_name_length;

	//Compute path with hashed file name
	if ((res = crypto_filename(path, enc_name_path, &encoded_name_length)))
		return res;

	//Open raw file
	if ((res = to_SE3_FRESULT(f_open(&(se_fp->fp), enc_name_path, mode))))
		return res;

	//Check if file size is a sector size multiple
	if (f_size(&se_fp->fp)%SE3_FATFS_SECTOR_SIZE != 0)
	{
		f_close(&se_fp->fp);
		return SE3_FR_DATA_ENC_ERROR;
	}

	//read header
	if((res = to_SE3_FRESULT(f_read(&(se_fp->fp), encoded_header_sector.data, sizeof(SE3_FATFS_SECTOR), &br))))
	{
		f_close(&se_fp->fp);
		return res;
	}

	if (br < sizeof(SE3_FATFS_SECTOR))
	{
		f_close(&se_fp->fp);
		return SE3_FR_HEADER_ENC_ERROR;
	}

	//read information stored in the header
	se_fp->algo = encoded_header_sector.header.algorithm;
	se_fp->keyID =  encoded_header_sector.header.key_id;
	if ((res = crypt_header(encoded_header_sector.data, header_sector.data, se_fp->algo, se_fp->keyID, SE3_DIR_DECRYPT)))
	{
		f_close(&se_fp->fp);
		return res;
	}
	memcpy(se_fp->IV, header_sector.header.nonce_ctr, SE3_FATFS_IV_LEN);


	return SE3_FR_OK;
}

//Writes decrypt buffer inside specified sector_id
//Valid sector_id(s) start from 1.
static
SE3_FRESULT write_sector(SE3_FIL* se_fp, uint32_t sector_id)
{
	SE3_FRESULT res;
	SE3_FATFS_SECTOR data_sector;
	SE3_FATFS_SECTOR encoded_data_sector;
	uint8_t sector_IV[SE3_FATFS_IV_LEN];


	if (sector_id == 0)
		return SE3_FR_INVALID_PARAMETER;

	//Place raw file pointer in the correct position
	if (f_tell(&(se_fp->fp)) != SE3_FATFS_SECTOR_SIZE*sector_id)
	{
		if ((res = to_SE3_FRESULT(f_lseek(&(se_fp->fp), SE3_FATFS_SECTOR_SIZE*sector_id))))
			return res;
	}

	//Prepare data to be encrypted
	memcpy(data_sector.logic_data, se_fp->decrypt_buffer, SE3_FATFS_LOGIC_DATA);
	data_sector.len = se_fp->decrypt_buffer_size;

	//Fill empty space with random data
	if (data_sector.len < SE3_FATFS_LOGIC_DATA)
	{
		se3_rand(SE3_FATFS_LOGIC_DATA-data_sector.len, data_sector.logic_data + data_sector.len);
	}


	compute_IV(se_fp->IV, sector_IV, sector_id);

	//Encrypt sector
	if ((res = crypt_sector(data_sector.data, encoded_data_sector.data, se_fp->algo, se_fp->keyID, sector_IV, SE3_DIR_ENCRYPT)))
		return res;

	//Write encrypted sector in raw file
	if ((res = to_SE3_FRESULT(f_write(&(se_fp->fp), encoded_data_sector.data, SE3_FATFS_SECTOR_SIZE, NULL))))
		return res;

	return SE3_FR_OK;

}


/*
 * Reads a sector, decrypts it and places it in *data* parameter.
 * We need this kind of flexibility (in opposition to the write_sector function)
 * 	to read the last sector for filesize computation without affecting decrypt_buffer.
 * Valid sector_id(s) start from 1.
*/
static
SE3_FRESULT read_sector(SE3_FIL* se_fp, uint32_t sector_id, uint8_t* data, uint16_t* data_len)
{
	SE3_FRESULT res;
	SE3_FATFS_SECTOR data_sector;
	SE3_FATFS_SECTOR encoded_data_sector;
	UINT br;
	uint8_t sector_IV[SE3_FATFS_IV_LEN];

	if (sector_id == 0)
		return SE3_FR_INT_ERR;

	//Place raw file pointer in the correct position
	if (f_tell(&(se_fp->fp)) != SE3_FATFS_SECTOR_SIZE*sector_id)
	{
		if ((res = to_SE3_FRESULT(f_lseek(&(se_fp->fp), SE3_FATFS_SECTOR_SIZE*sector_id))))
			return res;
	}

	//Read encrypted data
	if ((res = to_SE3_FRESULT(f_read(&(se_fp->fp), encoded_data_sector.data, SE3_FATFS_SECTOR_SIZE, &br))))
		return res;

	//Check for end of file
	if (br == 0)
		return SE3_FR_EOF;
	else if (br < SE3_FATFS_SECTOR_SIZE)
		return SE3_FR_DATA_ENC_ERROR;

	compute_IV(se_fp->IV, sector_IV, sector_id);

	//Decrypt sector
	if ((res = crypt_sector(encoded_data_sector.data, data_sector.data, se_fp->algo, se_fp->keyID, sector_IV, SE3_DIR_DECRYPT)))
		return res;

	//Copy plaintext data
	if (data != NULL)
		memcpy(data, data_sector.logic_data, SE3_FATFS_LOGIC_DATA);
	if (data_len != NULL)
		*data_len = data_sector.len;

	return SE3_FR_OK;
}

static
void compute_IV(uint8_t* base_IV, uint8_t* sector_IV, uint32_t sector_id)
{
	uint32_t current_block_index = (sector_id - 1) * (SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE / B5_AES_BLK_SIZE);
	uint8_t old_V, cb = 0;
	uint8_t j;
	memcpy(sector_IV, base_IV, SE3_FATFS_IV_LEN);
	j = 15;
	do {
		old_V = sector_IV[j];
		sector_IV[j] += current_block_index & 0xFF;
		current_block_index = (current_block_index>>8);
		if (cb)
			sector_IV[j]++;
		cb = sector_IV[j] < old_V;
	} while( j-- && cb);
}

static
SE3_FRESULT crypt_sector(uint8_t* input_data, uint8_t* output_data, uint16_t algo, uint32_t keyID, uint8_t* IV, uint16_t direction)
{
	SE3_FRESULT res;
	uint32_t sid;

	if ( (res = initialise_crypto_context(algo, keyID, SE3_FEEDBACK_CTR | direction, &sid)))
		return res;

	if ((res = set_IV(sid, IV, SE3_FATFS_IV_LEN)))
		return res;


	if ((res = execute_crypto_sector(sid, input_data, output_data)))
		return res;

	if (direction == SE3_DIR_DECRYPT)
	{
		if (memcmp(input_data+SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE, output_data+SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE, SE3_FATFS_SIGNATURE_LEN))
			return SE3_FR_INVALID_SIGNATURE;
	}

	return SE3_FR_OK;
}

static
SE3_FRESULT set_IV(uint32_t sid, uint8_t* IV, uint16_t IV_len)
{
	uint16_t flags = SE3_CRYPTO_FLAG_SETIV;

	uint8_t request[SE3_CRYPTO_MAX_DATAIN];
	uint8_t response[SE3_CRYPTO_MAX_DATAOUT];
	uint16_t response_size = 0;
	uint16_t request_size = 0;

	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_SID, &sid, 4);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_FLAGS, &flags, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN1_LEN, &IV_len, 2);
	memset(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN2_LEN, 0, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA, IV, IV_len);

	request_size = 4 + 2 + 2 + IV_len;

	if((crypto_update(request_size, request, &response_size, response)) != SE3_OK){
		return SE3_FR_CYPHER_ERROR;
		}

	return SE3_FR_OK;
}

static
SE3_FRESULT execute_crypto_sector(uint32_t sid, uint8_t* input_data, uint8_t* output_data)
{
	uint16_t flags = SE3_CRYPTO_FLAG_FINIT | SE3_CRYPTO_FLAG_AUTH;


	size_t datain_len = SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE;

	uint8_t request[SE3_CRYPTO_MAX_DATAIN];
	uint8_t response[SE3_CRYPTO_MAX_DATAOUT];
	uint16_t response_size = 0;
	uint16_t request_size = 0;

	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_SID, &sid, 4);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_FLAGS, &flags, 2);
	memset(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN1_LEN, 0, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN2_LEN, &datain_len, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA, input_data, datain_len);

	request_size = 4 + 2 + 2 + datain_len;

	if((crypto_update(request_size, request, &response_size, response)) != SE3_OK){
		return SE3_FR_CYPHER_ERROR;
	}

	memcpy(((uint8_t*)output_data), ((uint8_t*)response) + SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATA, response_size-SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATA); //copy response data

	return SE3_FR_OK;
}

static
SE3_FRESULT secure_create(SE3_FIL* se_fp, char* path, BYTE mode)
{
	SE3_FRESULT res;
	char enc_name_path[MAX_PATHNAME];
	uint16_t encoded_name_length;
	char filename[_MAX_LFN];
	uint8_t* padding_start;
	uint8_t* filename_start;
	size_t filename_len;


	//The first sector contains the header only
	SE3_FATFS_SECTOR header_sector;

	if (!key_exists(se_fp->keyID))
		return SE3_FR_NO_KEY;
	if (se_fp->algo > SE3_ALGO_MAX)
		return SE3_FR_INVALID_ALGO;

	uint8_t encoded_header_sector[sizeof(SE3_FATFS_SECTOR)];

	res = crypto_filename(path, enc_name_path, &encoded_name_length);
		if (res != SE3_FR_OK)
			return res;

	res = to_SE3_FRESULT(f_open(&(se_fp->fp), enc_name_path, mode));
	if (res != SE3_FR_OK)
		return res;

	//Prepare header
	se3_rand(SE3_FATFS_NONCE_LEN, (uint8_t*) &(header_sector.header.nonce_pbkdf2));
	header_sector.header.key_id = se_fp->keyID;
	header_sector.header.algorithm = se_fp->algo;
	memset(&(header_sector.header.padding), 0, 10);

	se3_rand(sizeof(header_sector.header.magic), (uint8_t*) &(header_sector.header.magic));
	se3_rand(SE3_FATFS_IV_LEN, (uint8_t*) &(header_sector.header.nonce_ctr));
	se3_rand(sizeof(header_sector.header.uid), (uint8_t*) &(header_sector.header.uid));
	se3_rand(sizeof(header_sector.header.uid_cnt), (uint8_t*) &(header_sector.header.uid_cnt));
	se3_rand(sizeof(header_sector.header.ver), (uint8_t*) &(header_sector.header.ver));

	//Populate filename
	get_filename(path, filename, _MAX_LFN);
	filename_len = strnlen(filename, _MAX_LFN);
	header_sector.header.fname_len = filename_len;
	filename_start = header_sector.data + sizeof(SE3_FATFS_HEADER);
	memcpy(filename_start, filename, filename_len);

	//Populate padding
	padding_start = (uint8_t*) header_sector.data + sizeof(SE3_FATFS_HEADER)+filename_len;
	se3_rand(SE3_FATFS_LOGIC_DATA-sizeof(SE3_FATFS_HEADER)-filename_len, padding_start);
	header_sector.len = sizeof(SE3_FATFS_HEADER) + filename_len;

	//Encrypt header
	if ( (res = crypt_header(header_sector.data, encoded_header_sector, se_fp->algo, se_fp->keyID, SE3_DIR_ENCRYPT) ))
		return res;

	//Write encrypted header in raw file
	if ((res = to_SE3_FRESULT(f_write(&(se_fp->fp), encoded_header_sector, SE3_FATFS_SECTOR_SIZE, NULL))))
		return res;

	//copy generated IV in se_fp structure
	memcpy(se_fp->IV, header_sector.header.nonce_ctr, SE3_FATFS_IV_LEN);


	return SE3_FR_OK;
}

static
SE3_FRESULT crypt_header(uint8_t* input_data, uint8_t* output_data, uint16_t algo, uint32_t keyID, uint16_t direction)
{
	SE3_FRESULT res;
	uint32_t sid;

	uint8_t *nonce_pbkdf2 = (uint8_t*)input_data;

	if ( (res = initialise_crypto_context(algo, keyID, SE3_FEEDBACK_ECB | direction, &sid)))
		return res;

	if ( (res = set_nonce(sid, nonce_pbkdf2, SE3_FATFS_NONCE_LEN)))
			return res;

	if ( (res = execute_crypto_header(sid, input_data, output_data)))
		return res;

	if (direction == SE3_DIR_DECRYPT)
	{
		if (memcmp(input_data+SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE, output_data+SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE, SE3_FATFS_SIGNATURE_LEN))
			return SE3_FR_INVALID_SIGNATURE;
	}

	return SE3_FR_OK;
}



static
SE3_FRESULT initialise_crypto_context(uint16_t algo, uint32_t keyID, uint16_t mode, uint32_t* sid)
{
	uint8_t request[1024];
	uint8_t response[SE3_CMD1_CRYPTO_INIT_RESP_SIZE];
	uint16_t response_size;

	memcpy(request + SE3_CMD1_CRYPTO_INIT_REQ_OFF_ALGO, &algo, 2);
	memcpy(request + SE3_CMD1_CRYPTO_INIT_REQ_OFF_MODE, &mode, 2);
	memcpy(request + SE3_CMD1_CRYPTO_INIT_REQ_OFF_KEY_ID, &keyID, 4);
	uint16_t rc = crypto_init(SE3_CMD1_CRYPTO_INIT_REQ_SIZE, request, &response_size, response);
	if((rc != SE3_OK) || (response_size != SE3_CMD1_CRYPTO_INIT_RESP_SIZE)){
		return SE3_FR_CYPHER_ERROR;
	}
	memcpy(sid, response+SE3_CMD1_CRYPTO_INIT_RESP_OFF_SID, SE3_CMD1_CRYPTO_INIT_RESP_SIZE); // get session id from crypto_init()
	return SE3_FR_OK;
}

static
SE3_FRESULT set_nonce(uint32_t sid, uint8_t* nonce, uint16_t nonce_len)
{
	uint16_t flags = SE3_CRYPTO_FLAG_SETNONCE;

	uint8_t request[SE3_CRYPTO_MAX_DATAIN];
	uint8_t response[SE3_CRYPTO_MAX_DATAOUT];
	uint16_t response_size = 0;
	uint16_t request_size = 0;

	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_SID, &sid, 4);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_FLAGS, &flags, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN1_LEN, &nonce_len, 2);
	memset(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN2_LEN, 0, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA, nonce, nonce_len);

	request_size = 4 + 2 + 2 + nonce_len;

	if((crypto_update(request_size, request, &response_size, response)) != SE3_OK){
		return SE3_FR_CYPHER_ERROR;
		}

	return SE3_FR_OK;
}

static
SE3_FRESULT execute_crypto_header(uint32_t sid, uint8_t* input_data, uint8_t* output_data)
{
	uint16_t flags = SE3_CRYPTO_FLAG_FINIT | SE3_CRYPTO_FLAG_AUTH;


	size_t datain_len = SE3_FATFS_SECTOR_ENCRYPTED_DATA_SIZE;
	datain_len -= (SE3_FATFS_NONCE_LEN + SE3_FATFS_HEADER_PLAINTXT_LEN);

	uint8_t request[SE3_CRYPTO_MAX_DATAIN];
	uint8_t response[SE3_CRYPTO_MAX_DATAOUT];
	uint16_t response_size = 0;
	uint16_t request_size = 0;

	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_SID, &sid, 4);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_FLAGS, &flags, 2);
	memset(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN1_LEN, 0, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN2_LEN, &datain_len, 2);
	memcpy(request+SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA, input_data + (SE3_FATFS_NONCE_LEN + SE3_FATFS_HEADER_PLAINTXT_LEN), datain_len);

	request_size = 4 + 2 + 2 + datain_len;

	if((crypto_update(request_size, request, &response_size, response)) != SE3_OK){
		return SE3_FR_CYPHER_ERROR;
	}

	memcpy(((uint8_t*)output_data)+SE3_FATFS_NONCE_LEN + SE3_FATFS_HEADER_PLAINTXT_LEN, ((uint8_t*)response) + SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATA, response_size-SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATA); //copy response data

	memcpy(((uint8_t*)output_data)+SE3_FATFS_NONCE_LEN, ((uint8_t*)input_data)+SE3_FATFS_NONCE_LEN, SE3_FATFS_HEADER_PLAINTXT_LEN); // copy sekey header as plaintext
	memcpy(output_data, input_data, SE3_FATFS_NONCE_LEN); // copy the field named "nonce_pbkdf2" as plaintext into the header

	return SE3_FR_OK;
}



static
bool key_exists(uint32_t keyID)
{
	se3_flash_it iterator;

	if (!se3_key_find(keyID, &iterator))
		return false;

	return true;
}

static
SE3_FRESULT crypto_filename(char *path, char *enc_name_path,
		uint16_t *encoded_length)
{
	if ((path == NULL) || (enc_name_path == NULL))
	{
		return SE3_FR_INVALID_NAME;
	}
	uint8_t orig_filename[_MAX_LFN+1];
	uint8_t SHAName[2*B5_SHA256_DIGEST_SIZE+1];
	uint8_t dirPath[MAX_PATHNAME];
	uint16_t lorig;
	int dirPathLen;

	get_filename(path, (char*) orig_filename, _MAX_LFN);
	get_path(path, (char*) dirPath);
	lorig = strnlen((const char*) orig_filename, _MAX_LFN);

	if (strlen((const char*) dirPath) > MAX_PATHNAME - 2 * B5_SHA256_DIGEST_SIZE)
	{
		return SE3_FR_FILENAME_ENC_ERROR;
	}

	getSHA256string(orig_filename, lorig, SHAName);

	dirPathLen = strlen((const char*) dirPath);
	if (encoded_length != NULL)
		*encoded_length = (2*B5_SHA256_DIGEST_SIZE+1) * 2 + dirPathLen;

	if (dirPath[0])
	{
		memcpy(enc_name_path, dirPath, dirPathLen);
	}
	memcpy(enc_name_path + dirPathLen, SHAName, 2*B5_SHA256_DIGEST_SIZE+1);
	return SE3_FR_OK;
}

static
SE3_FRESULT getSHA256string(uint8_t* input, int length, uint8_t* output)
{
	B5_tSha256Ctx ctx;
	uint8_t bufferName[B5_SHA256_DIGEST_SIZE];
	uint8_t* pout;
	uint16_t i;
	const char * hex = "0123456789abcdef";

	pout = output;

	if ((B5_SHA256_RES_OK != B5_Sha256_Init(&ctx)))
	{
		return SE3_FR_FILENAME_ENC_ERROR;
	}
	if ((B5_SHA256_RES_OK != B5_Sha256_Update(&ctx, (uint8_t*) input, length)))
	{
		return SE3_FR_FILENAME_ENC_ERROR;
	}
	if ((B5_SHA256_RES_OK != B5_Sha256_Finit(&ctx, (uint8_t*) bufferName)))
	{
		return SE3_FR_FILENAME_ENC_ERROR;
	}

	for (i = 0; i < B5_SHA256_DIGEST_SIZE; i++)
	{
		//sprintf((char*) &(output[i * 2]), "%02x", (uint8_t) bufferName[i]);
		*pout++ = hex[(bufferName[i]>>4)&0xF];
		*pout++ = hex[(bufferName[i])&0xF];
	}

	*pout = 0;

	return SE3_FR_OK;
}

static
void get_path(char *full_path, char *path)
{
	if ((full_path == NULL) || (path == NULL))
	{
		return;
	}
	char *p_name;
	p_name = strrchr(full_path, '/');
	if (p_name == NULL)
	{
		p_name = strrchr(full_path, '\\');
		if (p_name == NULL)
		{
			path[0] = '\0';
		}
		else
		{
			memcpy(path, full_path, p_name - full_path + 1);
			path[p_name - full_path + 1] = '\0';
		}
	}
	else
	{
		memcpy(path, full_path, p_name - full_path + 1);
		path[p_name - full_path + 1] = '\0';
	}
}

static
void get_filename(char *path, char *file_name, size_t maxLength)
{
	if ((file_name == NULL) || (path == NULL))
	{
		return;
	}
	char *f_name;
	f_name = strrchr(path, '/');
	if (f_name == NULL)
	{
		f_name = strrchr(path, '\\');
		if (f_name == NULL)
		{
			memcpy(file_name, path, maxLength);
		}
		else
		{
			memcpy(file_name, f_name + 1, maxLength);
		}
	}
	else
	{
		memcpy(file_name, f_name + 1, maxLength);
	}
}

static
SE3_FRESULT get_filesize(SE3_FIL* se_fp, uint32_t* filesize)
{
	uint32_t real_file_size, data_sectors;
	uint16_t last_sector_size;
	SE3_FRESULT res;

	real_file_size = (uint32_t) f_size(&(se_fp->fp));

	data_sectors = real_file_size / SE3_FATFS_SECTOR_SIZE - 1;
	if (( res = read_sector(se_fp, data_sectors, NULL, &last_sector_size)))
		return res;
	*filesize = (data_sectors - 1) * SE3_FATFS_LOGIC_DATA + last_sector_size;

	return SE3_FR_OK;
}

/*
 * Test some fields in order to detect if a SE_FIL struct
 * has not been initialized, in order to avoid an undefined behavior.
 * It is not bulletproof, always test the result of secure_open() !!!
 */
static
bool validate_file_object(SE3_FIL* se_fp)
{
	if (se_fp == NULL)
		return false;

	if (se_fp->fp.fs == NULL)
		return false;

	if (se_fp->algo > SE3_ALGO_MAX)
		return false;

	if (se_fp->decrypt_buffer_size > SE3_FATFS_LOGIC_DATA)
		return false;


	return true;
}

static
SE3_FRESULT set_file_pointer(SE3_FIL* se_fp, uint32_t new_pointer)
{

	uint32_t curr_sector, target_sector;
	SE3_FRESULT res;

	target_sector = new_pointer /  SE3_FATFS_LOGIC_DATA + 1 ;
	curr_sector = se_fp->pointer / SE3_FATFS_LOGIC_DATA + 1;

	if(curr_sector != target_sector)
	{
		//Save current sector if needed
		if (se_fp->decrypt_buffer_size > 0 && se_fp->dirty_bit)
		{
			if ( (res = write_sector(se_fp, curr_sector)) )
				return res;
		}


		res = read_sector(se_fp, target_sector, se_fp->decrypt_buffer, &se_fp->decrypt_buffer_size);

		//Create a new sector if reached end of file
		if (res == SE3_FR_EOF)
			se_fp -> decrypt_buffer_size = 0;
		else if (res != SE3_FR_OK)
			return res;

		se_fp->dirty_bit = false;
	}

	//Set logic file pointer
	se_fp->pointer = new_pointer;



	return SE3_FR_OK;
}

static
SE3_FRESULT to_SE3_FRESULT(FRESULT res)
{
	switch (res) {
		case FR_OK: return SE3_FR_OK;
		case FR_DISK_ERR: return SE3_FR_DISK_ERR;
		case FR_INT_ERR: return SE3_FR_INT_ERR;
		case FR_NOT_READY: return SE3_FR_NOT_READY;
		case FR_NO_FILE: return SE3_FR_NO_FILE;
		case FR_NO_PATH: return SE3_FR_NO_PATH;
		case FR_INVALID_NAME: return SE3_FR_INVALID_NAME;
		case FR_DENIED: return SE3_FR_DENIED;
		case FR_EXIST: return SE3_FR_EXIST;
		case FR_INVALID_OBJECT: return SE3_FR_INVALID_OBJECT;
		case FR_WRITE_PROTECTED: return SE3_FR_WRITE_PROTECTED;
		case FR_INVALID_DRIVE: return SE3_FR_INVALID_DRIVE;
		case FR_NOT_ENABLED: return SE3_FR_NOT_ENABLED;
		case FR_NO_FILESYSTEM: return SE3_FR_NO_FILESYSTEM;
		case FR_MKFS_ABORTED: return SE3_FR_MKFS_ABORTED;
		case FR_TIMEOUT: return SE3_FR_TIMEOUT;
		case FR_LOCKED: return SE3_FR_LOCKED;
		case FR_NOT_ENOUGH_CORE: return SE3_FR_NOT_ENOUGH_CORE;
		case FR_TOO_MANY_OPEN_FILES: return SE3_FR_TOO_MANY_OPEN_FILES;
		case FR_INVALID_PARAMETER: return SE3_FR_INVALID_PARAMETER;
		default: return SE3_FR_INT_ERR;
	}
}
